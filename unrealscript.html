<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>UnrealScript - Sagittarius Wiki</title>
	<script src="js/main.js"></script>
	<script>printFavicon();</script>

	<link href="css/bootstrap.css" rel="stylesheet" />
	<link href="css/bootstrap-responsive.css" rel="stylesheet" />
	<link href="css/docs.css" rel="stylesheet" />
	<link href="css/prettify.css" rel="stylesheet" />

	<!--[if lt IE 9]>
		<script src="js/html5shiv.js"></script>
	<![endif]-->
</head>
<body data-spy="scroll" data-target=".bs-docs-sidebar">
	<script>printNav("UnrealScript");</script>

	<header class="jumbotron subhead" id="overview">
		<div class="container">
			<h1>UnrealScript</h1>
			<p class="lead">The tutorial hub for the UnrealScript starter kit</p>
		</div>
	</header>

	<div class="container">
		<div class="row">
			<div class="span3 bs-docs-sidebar">
				<ul class="nav nav-list bs-docs-sidenav">
					<li><a href="#basic-integration"><i class="icon-chevron-right"></i>Basic Integration</a></li>
					<li><a href="#easy-motd-module"><i class="icon-chevron-right"></i>Easy: MOTD Module</a></li>
					<li><a href="#medium-server-browser"><i class="icon-chevron-right"></i>Medium: Server Browser</a></li>
					<li><a href="#logging"><i class="icon-chevron-right"></i>Logging</a></li>
				</ul>
			</div>
			<div class="span9">

				<section id="basic-integration">
					<div class="page-header">
						<h1>Basic Integration</h1>
					</div>

					<h2 id="copying-files">Copying Files</h2>
					<p>The easiest way to integrate the starter kit with your game is to simply copy all the .uc files into your source directory (which will be something similar to <code>\Development\Src\MyGame\Classes\</code>). They should compile successfully out of the box.</p>
					<p>An alternative is to create a new directory just for Sagittarius, such as <code>\Development\Src\Sagittarius\Classes\</code>, and place the starter kit there. You will have to modify <code>DefaultEngine.ini</code> to let UDK know to compile the new classes:</p>
<pre class="prettyprint">
[UnrealEd.EditorEngine]
+EditPackages=UTGame
+EditPackages=UTGameContent
+EditPackages=Sagittarius
+EditPackages=MyGame
</pre>
					<p>Make sure to place Sagittarius before your game's directory, as the Sagittarius sources must be compiled first. This method is recommended to keep Sagittarius code separate from your projects. You should never have to touch any of the starter kit classes, and updating to a newer starter kit version will simply mean overwriting the contents of the <code>\Sagittarius\Classes\</code> folder.</p>

					<h2 id="the-gameinfo-class">The GameInfo Class</h2>
					<p>A class called <code>SagittariusGame.uc</code> is included with the starter kit to show the minimum amount of code needed to get Sagittarius up and running. You should copy this code into your own GameInfo class. Make sure to replace <code>[APP ID HERE]</code> in the DefaultProperties block with your own application ID.</p>
					<p>At this point Sagittarius will be fully integrated and ready to use, but it can't really do anything just yet. To start leveraging its power you will need to write some <i>modules</i>.</p>
				</section>

				<section id="easy-motd-module">
					<div class="page-header">
						<h1>Easy: MOTD Module</h1>
					</div>
					
					<h2 id="understanding-modules">Understanding Modules</h2>
					<p>Sagittarius is structured around the idea of <span class="label label-important">MODULES</span> that perform <span class="label label-important">ACTIONS</span>. If you look in the starter kit you will notice two base classes, <code>Action.uc</code> and <code>Module.uc</code>. The actions that Sagittarius is capable of performing are fixed; that is, you will never have to write a subclass of <code>Action.uc</code>. You <i>will</i>, however, have to create modules that use the actions available to Sagittarius.</p>
					<p>In order to use a module you will have to <strong>register</strong> it to Sagittarius and <strong>retrieve</strong> it when you want to use it. In many ways Sagittarius acts as a &ldquo;module manager&rdquo;. The great thing is that you can write and register as many modules as you'd like: a Server Module, a Login Module, and so on -- one for each of the features you'd like your game to support.</p>
					<p>To better understand how modules work, let's write a simple Message of the Day Module.</p>

					<h2 id="uploading-a-motd">Uploading a MOTD</h2>
					<p>Before we start coding, we need to define what we want our MOTD to be and actually host one on our App Engine application. Our MOTD will be extremely simple, just a single string that we will call the &ldquo;message&rdquo;. A full MOTD DBObject might look something like this:</p>
<pre class="prettyprint">
object_type="motd"
object_name="motd"
message="Welcome to my game, have fun playing!"
</pre>
					<p>The first two attributes are required, so we'll simply set them as <code>"motd"</code> to make filtering for the MOTD easier.</p>
					<p>Now we need to upload our message. You can use the <a href="wizard.html">Sagittarius Wizard</a> to do this. If this is your first time uploading a MOTD, add an <strong>Add Action</strong> button followed by three <strong>Add Attribute</strong> buttons to set the attributes to the values listed above. If you already have a MOTD, you can add a <strong>Modify Action</strong> instead to modify the message attribute.</p>

					<h2 id="defining-our-class">Defining Our Class</h2>
					<p>The first thing we'll do code-wise is create a new class extending from <code>Module.uc</code> and copy over all the necessary functions:</p>
<pre class="prettyprint linenums pre-scrollable">
class MOTDModule extends Module;

function OnTextReceived(string ActionID, string Text)
{
	super.OnTextReceived(ActionID, Text);
	// When any text is received from remote service
}

function OnCallbackReceived(string ActionID)
{
	super.OnCallbackReceived(ActionID);
	// When remote transmission is fully completed
}

DefaultProperties
{
	ID="motd"
}
</pre>
					<p>Save this file as <code>MOTDModule.uc</code> in your project's source directory. Every module you create should have at least this basic skeleton. Although you do not need to override the <code>OnTextReceived()</code> or <code>OnCallbackReceived()</code> functions, you must specify a module ID in the DefaultProperties block. This ID will be used by Sagittarius to identify and retrieve instances of this module, and should be unique (otherwise, modules could be confused for each other).</p>

					<h2 id="the-delegate-pattern">The Delegate Pattern</h2>
					<p>Anything that relies on an Internet connection is <strong>asynchronous</strong>. That is, we cannot predict how long it will take for us to send data to our App Engine application, or when the server will reply. Because of this, we cannot simply wait for a response; we want to be <strong>notified</strong> when a response is received. This is a job for <a href="http://udn.epicgames.com/Three/UnrealScriptDelegates.html">UnrealScript delegates</a>.</p>
					<p>Sagittarius masks most of the complexity of delegates and event handling for you, piping all notifications through the <code>OnTextReceived()</code> and <code>OnCallbackReceived()</code> functions we've already declared. However, your game will be interacting with your modules directly, so we need another layer of delegates within each module you make. Thankfully there is a very simple <i>delegate pattern</i> to follow:</p>
<pre class="prettyprint linenums pre-scrollable">
class MOTDModule extends Module;

delegate OnMOTDReceivedDelegate();

function RegisterOnMOTDReceivedDelegate(delegate&lt;OnMOTDReceivedDelegate&gt; del)
{
	OnMOTDReceivedDelegate = del;
}

function OnTextReceived(string ActionID, string Text)
{
	super.OnTextReceived(ActionID, Text);
	// When any text is received from remote service
}

function OnCallbackReceived(string ActionID)
{
	super.OnCallbackReceived(ActionID);
	OnMOTDReceivedDelegate();
}

DefaultProperties
{
	ID="motd"
}
</pre>
					<p>A class (such as your GameInfo class) that wants to know when the Message of the Day has been received simply registers a function to call through <code>RegisterOnMOTDReceivedDelegate()</code>. When everything is done, <code>OnCallbackReceived()</code> is called, and in turn <code>OnMOTDReceivedDelegate()</code>, which then in turn calls the function you registered.</p>
					<p>We'll see this pattern in action a little later on, but for now you should remember how to set it up:</p>
					<ul>
						<li>Declare a delegate</li>
						<li>Make a function that registers a function to this delegate</li>
						<li>Call the delegate when you want to notify that something has been done</li>
					</ul>

					<h2 id="caching-the-motd">Caching the MOTD</h2>
					<p>Every time you communicate with your App Engine application, you use a tiny bit of its <a href="https://developers.google.com/appengine/docs/quotas">quota</a>. If you go over the quota your application will go down (equivalent to a crash), so it's important to communicate only when absolutely necessary.</p>
					<p>In the case of the Message of the Day, we expect the message to change approximately once every 24 hours -- not very often, in other words. Although the MOTD may be updated while the player is playing, we will assume that this scenario is very unlikely. So, we can get away with only querying for the MOTD <i>once</i>: upon starting the game.</p>
					<p>The typical way to handle data from Sagittarius is to maintain a <strong>local cache</strong> of it. When you ask Sagittarius for new information, the local cache is updated. Although we might get the MOTD value often (every time the player exits to the main menu, for example), we are really only getting its cached value. Let's code this now:</p>
<pre class="prettyprint linenums pre-scrollable">
class MOTDModule extends Module;

var string motd;

delegate OnMOTDReceivedDelegate();

function RegisterOnMOTDReceivedDelegate(delegate&lt;OnMOTDReceivedDelegate&gt; del)
{
	OnMOTDReceivedDelegate = del;
}

/**
 * Gets the cached MOTD value.
 */
function string GetMOTD()
{
	return motd;
}

/**
 * Gets and stores the MOTD from Sagittarius.
 */
function QueryMOTD()
{
	// @TODO
}

function OnTextReceived(string ActionID, string Text)
{
	super.OnTextReceived(ActionID, Text);
	// When any text is received from remote service
}

function OnCallbackReceived(string ActionID)
{
	super.OnCallbackReceived(ActionID);
	OnMOTDReceivedDelegate();
}

DefaultProperties
{
	ID="motd"
}
</pre>
					<p>We have added two new functions. You will call <code>GetMOTD()</code> whenever you want to know the MOTD, for example from a Scaleform GFx menu class. When you want to update the MOTD with the value on the server, you can call <code>QueryMOTD()</code>. This can be done when the game starts up, for example in a <code>PostBeginPlay()</code> function.</p>

					<h2 id="querying-the-motd">Querying the MOTD</h2>
					<p>Since we only really want to <i>get</i> the latest MOTD from the server, our <code>QueryMOTD()</code> function will only need to implement a single action, appropriately called GetAction:</p>
<pre class="prettyprint linenums pre-scrollable">
class MOTDModule extends Module;

var string motd;

delegate OnMOTDReceivedDelegate();

function RegisterOnMOTDReceivedDelegate(delegate&lt;OnMOTDReceivedDelegate&gt; del)
{
	OnMOTDReceivedDelegate = del;
}

/**
 * Gets the cached MOTD value.
 */
function string GetMOTD()
{
	return motd;
}

/**
 * Gets and stores the MOTD from Sagittarius.
 */
function QueryMOTD()
{
	local GetAction ga;
	ga = new class'GetAction';
	ga.AddFilter(ga.DBTYPE, "motd");
	ga.AddFilter(ga.DBNAME, "motd");
	ga.AddProjection("message");
	ga.Unique();
	SubmitAction("motdquery", ga);
}

function OnTextReceived(string ActionID, string Text)
{
	super.OnTextReceived(ActionID, Text);
	motd = Parent.GetXMLValue("message", Text);
}

function OnCallbackReceived(string ActionID)
{
	super.OnCallbackReceived(ActionID);
	OnMOTDReceivedDelegate();
}

DefaultProperties
{
	ID="motd"
}
</pre>
					<p>Our added code shows how to make use of the actions bundled with the starter kit. First, we create a new instance of GetAction. Then we add our filters and projections to it. We only want to get the DBObject with <code>object_type=="motd"</code> and <code>object_name=="motd"</code>, so we add those filters using the special shortcut variables <code>DBTYPE</code> and <code>DBNAME</code> respectively. We only want to return the actual <i>message</i>, so we add a projection for that field. Since we expect there to be only one MOTD, we make the query unique. And finally, we submit the GetAction and assign it an ID of <code>"motdquery"</code> so that it can be identified later.</p>
					<p>Any time that Sagittarius receives a reply from the server, the text will be routed to <code>OnTextReceived()</code>. Therefore it is here that we want to parse the MOTD message and assign it to our local cache. Replies are XML-encoded, so we know the MOTD message will be wrapped by <code>&lt;message&gt;</code> tags. We get this value using the special function <code>GetXMLValue()</code>, and our module is complete.</p>

					<h2 id="using-our-motd-module">Using Our MOTD Module</h2>
					<p>Since this is a simple tutorial, we'll just modify <code>SagittariusGame.uc</code> to fetch the MOTD one second after a level has been loaded and broadcast it to all players. In a more realistic scenario you'd probably fetch the MOTD upon startup and integrate the message into a menu or HUD element. Our modifications are as follows:</p>
<pre class="prettyprint linenums pre-scrollable">
event PreBeginPlay()
{
	super.PreBeginPlay();
	Sag = Spawn(class'Sagittarius');
	Sag.Initialize(SagittariusHost, SagittariusPort);
	Sag.RegisterModule(new class'MOTDModule');
}

function PostBeginPlay()
{
	super.PostBeginPlay();
	SetTimer(1.0, false, 'GrabMOTD');
}

function GrabMOTD()
{
	local MOTDModule motd;
	motd = MOTDModule(Sag.GetModule("motd"));
	motd.RegisterOnMOTDReceivedDelegate(PrintMOTD);
	motd.QueryMOTD();
}

function PrintMOTD()
{
	Broadcast(self, MOTDModule(Sag.GetModule("motd")).GetMOTD());
}
</pre>
					<p>The first thing we do is <strong>register</strong> an instance of our MOTDModule to Sagittarius in <code>PreBeginPlay()</code>. In <code>PostBeginPlay()</code> we set a timer to call the function <code>GrabMOTD()</code>. In this function, we <strong>retrieve</strong> our module instance, register the function <code>PrintMOTD()</code> to its delegate, and ask it to query the server. Notice the use of delegates: when the module <i>does</i> receive a response from the server, we know our function <code>PrintMOTD()</code> will be called.</p>
					<p>All <code>PrintMOTD()</code> really does is broadcast what is in our module's local cache. However, remember that this separation of functionality is necessary because web connections are asynchronous.</p>
					<p>Now let's fire up a SagittariusGame. If all goes well, you should see something like this when the match starts up:</p>
					<img src="img/unrealscript-1.jpg" style="margin-bottom:10px;" />
					<p>Congratulations, you have just written your first module!</p>
				</section>

				<section id="medium-server-browser">
					<div class="page-header">
						<h1>Medium: Server Browser</h1>
					</div>
					<p class="lead">Coming soon!</p>
				</section>

				<section id="logging">
					<div class="page-header">
						<h1>Logging</h1>
					</div>
					<p>Sagittarius has a built-in log system that is slightly more robust than the UDK <code>`log()</code> macro. It supports conditional logging via an enum defined in <code>Sagittarius.uc</code>:</p>
<pre class="prettyprint">
var const enum ELogLevel
{
	LOG_None,
	LOG_Error,
	LOG_Warn,
	LOG_Info,
	LOG_Debug
} LogLevel;
</pre>
					<p>You can set the logging level in the DefaultProperties block of <code>Sagittarius.uc</code>. The levels are defined roughly as follows:</p>
					<ul>
						<li><strong>LOG_None</strong>: Log nothing at all</li>
						<li><strong>LOG_Error</strong>: Log only errors, which are unrecoverable faults that should be handled</li>
						<li><strong>LOG_Warn</strong>: Warnings are recoverable errors; there is a problem but the game can continue running</li>
						<li><strong>LOG_Info</strong>: General important information about connections is logged by default</li>
						<li><strong>LOG_Debug</strong>: Log everything, including debug information (which is typically verbose)</li>
					</ul>
					<p>To use the logging system, you can call the following functions defined in <code>Sagittarius.uc</code>:</p>
<pre class="prettyprint">
static function LogError(string msg, optional name cat = LOG_TAG)
static function LogWarn(string msg, optional name cat = LOG_TAG)
static function LogInfo(string msg, optional name cat = LOG_TAG)
static function LogDebug(string msg, optional name cat = LOG_TAG)
</pre>
					<p>The optional <code>LOG_TAG</code> is a tag that will be enclosed in brackets preceding the message in the log. If you decide to specify it, you would typically use the name of the class that you are logging from. Remember that logging is filtered by the <code>LogLevel</code>, so if your logging level is <code>LOG_Warn</code> but you call <code>LogInfo()</code>, that message will not be logged.</p>
					<p>Also, because all the logging functions are <strong>static</strong> you can use this system from any class:</p>
<pre class="prettyprint">
class'Sagittarius'.static.LogError("The Servers are Busy at this time. Please try again later.");
MySagittariusInstance.LogInfo("I can also do this using an instance of Sagittarius!");
</pre>
				</section>
			</div>
		</div>
	</div>

	<script>printFooter();</script>

	<script src="js/jquery.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/holder.js"></script>
	<script src="js/prettify.js"></script>
	<script src="js/application.js"></script>
</body>
</html>